package com.jasmine.Java高级.数据结构.树型结构.B树;

/**
 * @author : jasmineXz
 */
public class B树 {
    /**
     一. B 树(B-树)
        B树,又称为B-树,全称[Balance-Tree],中文全称多路平衡查找树
        ★ : B树和B+树因为其的高度小(即树较为矮胖,短宽),所以适合做为数据库的索引,因为的高度小,所以磁盘IO的次数较小.
             而树的每一层大小判断都是在内存中进行,所以多次判断的速度损失是可以接受的.
             二叉查找树尽管速度很快,但树的高度太高,磁盘IO的影响过大,不宜作为索引

        1. 特征
            例如一个M阶的B树
            1). 根节点至少有两个子女,即根节点至少两字子节点
            2). 每个<中间节点>都包含 k - 1 个元素和K个孩子,  其中 k <= M 且 k >= M/2
            3). 每个<叶子节点>都包含 k - 1 个元素,          其中 k <= M 且 k >= M/2
            4). 所有叶子节点都位于同一层
            5). 每个节点中的元素从小到大排列,节点当中 [k-1] 个元素正好是 k 个孩子包含的元素的值域划分.

            ★ : 即叶子节点的元素数量最多是 阶数-1
            ★ : 3阶的B树
            ★ : 每个节点最多包含3个孩子,2个元素
            ★ :        最少包含1个孩子,1个元素

            例如一个3阶的B树


                                     9                     -> 根节点至少有两个子节点
                               /           \
                            2    6           12            -> 3(k)个孩子  3(k)-1=2个元素 | 2(k)个孩子  2(k)-1=1个元素
                           /   |   \        /  \
                          1   3 5   8     11   13 15
                               ↑              ↑
                    1: 2(k)-1=1个元素         11: 2(k)-1=1个元素
                  3 5: 3(k)-1=2个元素      13 15: 3(k)-1=2个元素
                    8: 2(k)-1=1个元素

        2. 查询效率
            例如: 查询5,
            第一次磁盘IO,在内存中比较: 5 < 9
            第二次磁盘IO,在内存中比较: 2 < 5 < 6
            第三次磁盘IO,在内存中比较: 2 < 5 = 5

            ★ : B树在查询中的比较次数不比二叉查找树少,尤其是元素数量很多时
            ★ : 可是相比磁盘IO的速度,内存中的比较耗时几乎可以忽略,所以只要高度足够低,IO的次数足够少,就可以提升查找性能


        3. <总结> :
            1). 文件系统,非关系型数据大多使用B-树作为索引,因为自平衡.
            2). 查找单个目标速度块,但范围查找,排序等操作速度较慢,所以关系型数据库通常使用B+树.


     二. B+树
        B+树为B树(B-树)的一种改进,拥有更高的查询效率,但相对的更加占用内存.
        1. 特征
            1). 根节点至少有两个子女,即根节点至少两字子节点
            2). 有 K 个子节点的中间节点都包含 K 个元素,每个元素不保存数据,只用来做索引.
            3). 所有的叶子结点中包含了全部元素的信息,及指向含这些元素记录的指针,所有叶子节点有序排列,且形成一个有序链表
            4). 所有的中间节点元素都同时存在于子节点,在子节点元素中是最大(或最小)元素.
            5). 跟节点的最大元素,始终要是整个树的最大元素

            例如一个高为3的B+数
                                                       -> 5. 根节点的最大元素时整个树的最大元素
                             8    15                   -> 1. 根节点至少有两个子节点
                       /                \
                  2   5   8           11  15           -> 2. 有 3(k) 个子节点的中间节点都包含 3(k) 个元素
                                                       -> 4. 所有中间节点元素都同时存在于子节点,在子节点元素中是最大(或最小)元素.
                /     |     \        /      \
             1 2 (→) 3 5 (→) 8 (→) 9 11 (→) 13 15      -> 3. 叶子节点包含了树的全部信息,所有叶子节点有序排列,且形成一个有序链表

        2. 卫星数据
            B+树的特点,指的是索引元素锁指向的数据记录,例如B树中的每一个节点元素都带有卫星数据,即每一个元素都指向一行数据库中的记录.
            而在B+树中,只有叶子节点带有卫星数据,即只有找到叶子节点,才可以找到实际的数据库记录.

            ★ :    聚集索引（Clustered Index）   中，叶子节点直接包含卫星数据。
            ★ :  非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。

        3. 查询效率
            例如: 查询5,
            第一次磁盘IO,在内存中比较: 5 < 8
            第二次磁盘IO,在内存中比较: 5 = 5
            第三次磁盘IO,在内存中比较: 5 = 5

            ★ : 看起来IO次数同B-数相同,但因为中间节点没有卫星数据,所以同样大小的磁盘也可以容纳更多的节点元素.
                 这就意味着,数据量相同的情况下,B+树的结构比B-树更加矮胖,因此查询时IO次数也更少.
            ★ : 单个查询 : B+树的每一次查询都要找到叶子节点,而B-树只要找到匹配元素,因此B-树的查询性能并不稳定,最好是根节点,最坏是叶子节点
                           而,B+数的高度比B-树要低,所以B+树的性能是稳定的.
            ★ : 范围查询 : B-树的范围查询需要多次遍历直到找到所有在范围内的节点数.
                           而B+树只需要找到范围开始,接着通过叶子节点链表遍历即可找到范围内的全部元素.

        4. 总结
            1). 单一节点存储更多的元素，使得查询的IO次数更少。
            2). 所有查询都要查找到叶子节点，查询性能稳定。
            3). 所有叶子节点形成有序链表，便于范围查询。

     三. B*树


     */
}

