package com.jasmine.设计模式.装饰器模式_Decorator;

/**
 * @author : jasmineXz
 */
public class 概念 {
    /**
     一. 概念
        1. 举个例子:
            1).------------------------------------------------------------------------------------------------------
            假设我们有一个日志类,用于记录我们系统的日志.目前只有一个在控制台打印的功能.
            接口:
            interface log {
                print();
            }

            实现类:
            class console imp log {
                print(){
                    system.out.print("控制台")
                }
            }

            2).------------------------------------------------------------------------------------------------------
            后来我们有一个需求,要求我们将日志输出到本地文件中,那么需要怎么做呢?
            我们可以继承日志类,然后重写print方法
            class file imp log {
                print(){
                    system.out.print("文件")
                }
            }

            3).------------------------------------------------------------------------------------------------------
            现在又有需求,要求我们不输出到文件了,而是要将日志保存到数据库中.
            那么我们就再写一个类继承日志类,然后重写print方法
            class database imp log {
                print(){
                    system.out.print("数据库")
                }
            }

            4).------------------------------------------------------------------------------------------------------
            过了几天,项目经理和你说,我们要即输入到文件,也保存到数据库.那这时该怎么办呢?
            难道我们再写一个类继承日志类,把打印日志,写入文件,保存数据库这几件事全都再重写一遍吗?
            例如:
            class console imp log {
                print(){
                    system.out.print("控制台")
                }

                printFile(){
     system.out.print("控制台")
                }

                printFile(){

                }
            }

                @see com.jasmine.设计模式.装饰器模式_Decorator.演变例子_结合工厂.LogToAll
                这个方法没有错误,但他有几个问题.
                (1). 太多的继承,如果再需要拓展其他的功能,则需要继续继承LogImpl类,这样会造成子类过多的情况.
                (2). 代码没有复用.

                也许你说可以把方法封装呀,然后根据不同方法调用.
                例如:
                @see com.jasmine.设计模式.装饰器模式_Decorator.演变例子_结合工厂.LogImpl2
                这样实现功能当然是没毛病,但他存在几个问题.
                (1). 我们编写代码时,尽量去拓展方法它,而不是修改它.也就是要遵循开闭原则.
                (2). 代码依旧没有复用.
                (3). 多了很多自定义方法,造成方法混乱.

            5). 那么为了解决上面的问题,就可以用装饰器模式
                @see com.jasmine.设计模式.装饰器模式_Decorator.例子1.ZTest

        2. 来个图
            @link com.jasmine.设计模式.装饰器模式_Decorator.装饰器模式.jpg

        3. 概念
            装饰器模式其实是继承的一种替代方案.
            传统继承其实可以认为是一种纵向的拓展关系.而装饰器模式是一种横向的拓展关系.
     */
}
