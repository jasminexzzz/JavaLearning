package com.jasmine.JavaBase.线程.锁;

/**
 * @author : jasmineXz
 */
public class 概念 {
    /**
     (1).乐观锁/悲观锁

     乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

     悲观锁：(synchronized)总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，
     这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写
     锁等，都是在做操作之前先上锁。

     乐观锁：(lock)顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断
     一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据
     库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就
     是使用了乐观锁的一种实现方式CAS实现的。

     (2).公平锁/非公平锁

     对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平
     锁大。对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何
     办法使其变成公平锁。

     公平锁：是指多个线程按照申请锁的顺序来获取锁。

     非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能
     会造成优先级反转或者饥饿现象。

     (3).可重入锁/不可重入锁
     可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。
     对于Java ReentrantLock而言, 他的名字就可以看出是一个可重入锁，其名字是Re entrant Lock重新进入锁。
     对于Synchronized而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。

     不可重入锁：所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到
     被阻塞。可见 com.jasmine.JavaBase.线程.线程同步.锁.不可重入锁

     (4).独享锁/共享锁

     独享锁：该锁一次只能被一个线程所持有。

     共享锁：该锁可被多个线程所持有。

     对于Java ReentrantLock而言，其是独享锁。但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享
     锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。独享锁与共享锁也是通过AQS来实现的，通过
     实现不同的方法，来实现独享或者共享。对于Synchronized而言，当然是独享锁。

     (5).互斥锁/读写锁

     上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
     互斥锁在Java中的具体实现就是ReentrantLock。
     读写锁在Java中的具体实现就是ReadWriteLock。

     (6).分段锁



     (7).偏向锁/轻量级锁/重量级锁
     (8).自旋锁

     在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切
     换的消耗，缺点是循环会消耗CPU。
     */
}
