
#### 锁的总结

一句话总结:

---
**悲观锁** : 我使用数据时别人一定会改,所以我用的时候就加锁,别人阻塞.
<br>
**乐观锁** : 我使用的时候不管别人改不改,采用CAS算法.

---
**自旋锁** : 我得不到锁,但我不释放CPU,我再循环一次视图获得锁(以降低CPU切换的消耗.)
<br>
**非自旋锁** : 我得不到锁,我休眠释放CPU,锁被释放,我再唤醒,视图获得锁.
<br>
**适应性自旋锁** :

---
专门针对synchronized<br><br>
**无锁** : CAS其实就是无锁的一种
<br>
**偏向锁** : 我偏向某个线程,他来就直接获得锁.(如果一段同步代码一直被一个线程所访问,那该线程会自动获得这个锁,以降低CPU切换的消耗.)
<br>
**轻量级锁** : 两个线程竞争,偏向锁就变成了轻量级锁,让新来的线程自旋.
<br>
**重量级锁** : 如果新来的线程自旋了太多次,或者来了第三个线程,那就从轻量级升级为重量级锁.让其他锁都阻塞.
<br>

---
**公平锁** : 我要获得锁,拿不到我就排队拿.
<br>
**非公平锁** : 我要获得锁,拿得到我就直接拿,拿不到我再排队拿.

---
**可重入锁** : 如果我获得锁,那么再我释放锁之前,那么我的其他方法可以自动获得锁,不会阻塞.
<br>
**不可重入锁** : 和上面相反

---
**独享锁(排他锁/互斥锁)** : 我对某个数据加了锁,别的线程就不能加锁.
<br>
JDK中的synchronized和JUC中Lock都是互斥锁
<br>
**共享锁(读写锁)** :
<br>
ReentrantReadWriteLock

---

名称|乐观/悲观|读写/互斥|重入/非重入|公平/非公平|
--|--|--|--|--
synchronized|悲观|互斥|重入|非公平
ReentrantLock ( 可重入锁 )
ReadWriteLock ( 读写锁 )
ReentrantReadWriteLock


































- end
