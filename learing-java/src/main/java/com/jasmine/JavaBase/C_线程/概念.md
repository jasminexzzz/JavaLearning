# <center>AQS/LOCK/线程池</center>
## AbstractQueuedSynchronizer(AQS)

即队列同步器

它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。

### 主要对象
#### state

表示同步状态
  1. getState()：返回同步状态的当前值；
  2. setState(int newState)：设置当前同步状态；

#### Node 队列节点
##### 重要属性
- nextWaiter
- volatile Node prev : 元素的上一个节点
- volatile Node next : 元素的下一个节点
- volatile Thread thread : 等待的线程
- Node nextWaiter : 状态

```java
static final class Node {
  /** 共享 */
  static final Node SHARED = new Node();
  /** 独占 */
  static final Node EXCLUSIVE = null;
  /**
   * 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态；
   */
  static final int CANCELLED =  1;
  /**
   * 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行
   */
  static final int SIGNAL    = -1;
  /**
   * 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，改节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中
   */
   static final int CONDITION = -2;
  /**
   * 表示下一次共享式同步状态获取将会无条件地传播下去
   */
  static final int PROPAGATE = -3;    
  /** 等待状态 */    
  volatile int waitStatus;    
  /** 前驱节点 */    
  volatile Node prev;    
  /** 后继节点 */    
  volatile Node next;   
  /** 获取同步状态的线程 */    
  volatile Thread thread;    
  Node nextWaiter;    
  final boolean isShared() {        
    return nextWaiter == SHARED;    
  }    
  final Node predecessor() throws NullPointerException {        
    Node p = prev;        
    if (p == null)            
      throw new NullPointerException();        
    else            
    return p;    
  }    
  Node() {    }    
  Node(Thread thread, Node mode) {        
    this.nextWaiter = mode;        
    this.thread = thread;    
  }    
  Node(Thread thread, int waitStatus) {        
    this.waitStatus = waitStatus;        
    this.thread = thread;    
  }
}
```

#### CLH同步队列
CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。

![avatar](https://xiaozei-bucket.oss-cn-hangzhou.aliyuncs.com/xiaozei/blog/other/7d6b06d1092f43119a967cae6b2ac06c.jpg)

##### 重要属性

```java
/**
 * 等待队列的头，惰性初始化。除了初始化之外，它只通过setHead方法进行修改。注意:如果head存在，它的等待状态保证不会被取消。
 */
private transient volatile Node head;

/**
 * 等待队列的尾部，延迟初始化。仅通过方法enq修改以添加新的等待节点。
 */
private transient volatile Node tail;
```

##### 入列
未获取到锁的线程进入等待队列尾端

学了数据结构的我们，CLH队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法：

```java
/**
 * 为当前线程和给定模式创建并对节点进行排队。
 *
 * @param mode 节点
 * @return the new node
 */
private Node addWaiter(Node mode) {        
  //新建Node        
  Node node = new Node(Thread.currentThread(), mode);        
  //当前队列尾节点变为上一节点
  Node pred = tail;
  // 如果上一节点(尾节点)不为空
  if (pred != null) {
    // 当前节点的上一节点变为曾经的尾节点
    node.prev = pred;            
    // CAS设置尾节点            
    if (compareAndSetTail(pred, node)) {
      // 上一节点的下一节点为当前节点,即新增的节点
      // 新增的节点即为尾节点
      pred.next = node;                
      return node;            
    }
  }
  //多次尝试        
  enq(node);
  return node;
}
```
addWaiter(Node node)先通过快速尝试设置尾节点，如果失败，则调用enq(Node node)方法设置尾节点
```java
private Node enq(final Node node) {
  // 直到成功为止
  for (;;) {
    Node t = tail;
    // 尾节点不存在，则 [尾 = 首]
    if (t == null) {
      if (compareAndSetHead(new Node()))
        tail = head;
    // 尾节点存在,则节点的上一节点变为尾,尾的下一节点变为本节点.
    } else {
      // 设置为尾节点
      node.prev = t;
      if (compareAndSetTail(t, node)) {
        t.next = node;
        return t;
      }
    }
  }
}
```
如下图,节点添加到尾节点中

![avatar](https://xiaozei-bucket.oss-cn-hangzhou.aliyuncs.com/xiaozei/blog/other/1fae36ad19b247bf936c5a503f9f090d.jpg)

##### 出列
CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。

### 主要方法
1. 公平锁方式获取锁
```java
/**
 * 以排除模式获取，忽略中断。通过至少调用一次{@link #tryAcquire}来实现，成功后返回。
 * 否则，线程将排队，可能会重复阻塞和取消阻塞，调用{@link #tryAcquire}直到成功。
 * 此方法可用于实现方法{@link Lock# Lock}。
 *
 * @param 把获得参数设为参数。这个值被传递给 {@link #tryAcquire}，但是没有被解释，可以表示任何你喜欢的东西。
 */
public final void acquire(int arg) {
    // 去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。
    // 该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。
    if (!tryAcquire(arg) &&
        // addWaiter：如果tryAcquire返回FALSE（获取同步状态失败）则调用该方法将当前线程加入到CLH同步队列尾部。
        // acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        // selfInterrupt：产生一个中断。
        selfInterrupt();
}
```

- tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。该方法自定义同步组件自己实现，该方法必须要保证线程安全的获取同步状态。

- **addWaiter**：(上述介绍)如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。

- **acquireQueued**：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。

- selfInterrupt：产生一个中断。

acquireQueued 方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。
```java
final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
    //中断标志
    boolean interrupted = false;
    /*
    * 自旋过程，其实就是一个死循环而已
    */
    for (;;) {
      //当前线程的前驱节点
      final Node p = node.predecessor();
      //当前线程的前驱节点是头结点，且同步状态成功
      if (p == head && tryAcquire(arg)) {
        setHead(node);
        p.next = null; // help GC
        failed = false;
        return interrupted;
      }
      //获取失败，线程等待--具体后面介绍
      if (shouldParkAfterFailedAcquire(p, node)&&parkAndCheckInterrupt())
        interrupted = true;
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}

```
