# <center>AQS/LOCK/线程池</center>
## 一. AbstractQueuedSynchronizer(AQS)

即队列同步器

它是构建锁或者其他同步组件的基础框架（如ReentrantLock、ReentrantReadWriteLock、Semaphore等），JUC并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。它是JUC并发包中的核心基础组件。

### 1. 主要对象
#### 1.1 state

表示同步状态, 在可重入锁中也表示重入次数
  1. getState()：返回同步状态的当前值；
  2. setState(int newState)：设置当前同步状态；

#### 1.2 Node 队列节点
##### 1.2.1 重要属性
- nextWaiter
- volatile Node prev : 元素的上一个节点
- volatile Node next : 元素的下一个节点
- volatile Thread thread : 等待的线程
- Node nextWaiter : 状态

```java
static final class Node {
  // 共享
  static final Node SHARED = new Node();
  // 独占
  static final Node EXCLUSIVE = null;
  // 因为超时或者中断，节点会被设置为取消状态，被取消的节点时不会参与到竞争中的，他会一直保持取消状态不会转变为其他状态
  static final int CANCELLED =  1;
  // 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行
  static final int SIGNAL    = -1;
  // 节点在等待队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入到同步状态的获取中
  static final int CONDITION = -2;
  // 表示下一次共享式同步状态获取将会无条件地传播下去
  static final int PROPAGATE = -3;
  volatile     int waitStatus; // 等待状态

  volatile Node prev;      // 前驱节点
  volatile Node next;      // 后继节点
  volatile Thread thread;  // 获取同步状态的线程
  Node nextWaiter;    
  final boolean isShared() {        
    return nextWaiter == SHARED;    
  }    
  final Node predecessor() throws NullPointerException {        
    Node p = prev;        
    if (p == null)            
      throw new NullPointerException();        
    else            
    return p;    
  }    
  Node() {    }    
  Node(Thread thread, Node mode) {        
    this.nextWaiter = mode;        
    this.thread = thread;    
  }    
  Node(Thread thread, int waitStatus) {        
    this.waitStatus = waitStatus;        
    this.thread = thread;    
  }
}
```

#### 1.3 CLH同步队列
CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。

![avatar](https://xiaozei-bucket.oss-cn-hangzhou.aliyuncs.com/xiaozei/blog/other/7d6b06d1092f43119a967cae6b2ac06c.jpg)

##### 1.3.1 重要属性

```java
/**
 * 等待队列的头，惰性初始化。除了初始化之外，它只通过setHead方法进行修改。注意:如果head存在，它的等待状态保证不会被取消。
 */
private transient volatile Node head;

/**
 * 等待队列的尾部，延迟初始化。仅通过方法enq修改以添加新的等待节点。
 */
private transient volatile Node tail;
```

##### 1.3.2 入列
未获取到锁的线程进入等待队列尾端

学了数据结构的我们，CLH队列入列是再简单不过了，无非就是tail指向新节点、新节点的prev指向当前最后的节点，当前最后一个节点的next指向当前节点。代码我们可以看看addWaiter(Node node)方法：

```java
/**
 * 为当前线程和给定模式创建并对节点进行排队。
 *
 * @param mode 节点
 * @return the new node
 */
private Node addWaiter(Node mode) {        
  //新建Node        
  Node node = new Node(Thread.currentThread(), mode);        
  //当前队列尾节点变为上一节点
  Node pred = tail;
  // 如果上一节点(尾节点)不为空
  if (pred != null) {
    // 当前节点的上一节点变为曾经的尾节点
    node.prev = pred;            
    // CAS设置尾节点            
    if (compareAndSetTail(pred, node)) {
      // 上一节点的下一节点为当前节点,即新增的节点
      // 新增的节点即为尾节点
      pred.next = node;                
      return node;            
    }
  }
  //多次尝试        
  enq(node);
  return node;
}
```
addWaiter(Node node)先通过快速尝试设置尾节点，如果失败，则调用enq(Node node)方法设置尾节点
```java
private Node enq(final Node node) {
  // 直到成功为止
  for (;;) {
    Node t = tail;
    // 尾节点不存在，则 [尾 = 首]
    if (t == null) {
      if (compareAndSetHead(new Node()))
        tail = head;
    // 尾节点存在,则节点的上一节点变为尾,尾的下一节点变为本节点.
    } else {
      // 设置为尾节点
      node.prev = t;
      if (compareAndSetTail(t, node)) {
        t.next = node;
        return t;
      }
    }
  }
}
```
如下图,节点添加到尾节点中

![avatar](https://xiaozei-bucket.oss-cn-hangzhou.aliyuncs.com/xiaozei/blog/other/1fae36ad19b247bf936c5a503f9f090d.jpg)

##### 1.3.3 出列
CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单，head执行该节点并断开原首节点的next和当前节点的prev即可，注意在这个过程是不需要使用CAS来保证的，因为只有一个线程能够成功获取到同步状态。

---

### 2 主要方法
1. 获取锁　　 : public final void acquire(int arg)
2. 尝试获取锁 : protected boolean tryAcquire(int arg) 子类实现
3. 尝试释放锁 : protected boolean tryRelease(int arg) 子类实现

#### 2.1 获取锁 acquire(int arg)
由子类调用

- @param arg 把获得参数设为参数。这个值被传递给 {@link #tryAcquire}，但是没有被解释，可以表示任何你喜欢的东西。


```java
/**
 * 以排除模式获取，忽略中断。通过至少调用一次{@link #tryAcquire}来实现，成功后返回。
 * 否则，线程将排队，可能会重复阻塞和取消阻塞，调用{@link #tryAcquire}直到成功。
 * 此方法可用于实现方法{@link Lock# Lock}。
 */
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

- **tryAcquire** (见 2.2) : 去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。子类实现，该方法必须要保证线程安全的获取同步状态。

- **addWaiter** (见 1.3.2): 如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。

- **acquireQueued** (见 2.3)：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。

- selfInterrupt：产生一个中断。

acquireQueued 方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。
```java
final boolean acquireQueued(final Node node, int arg) {
  boolean failed = true;
  try {
    //中断标志
    boolean interrupted = false;
    /*
    * 自旋过程，其实就是一个死循环而已
    */
    for (;;) {
      //当前线程的前驱节点
      final Node p = node.predecessor();
      //当前线程的前驱节点是头结点，且同步状态成功
      if (p == head && tryAcquire(arg)) {
        setHead(node);
        p.next = null; // help GC
        failed = false;
        return interrupted;
      }
      //获取失败，线程等待--具体后面介绍
      if (shouldParkAfterFailedAcquire(p, node)&&parkAndCheckInterrupt())
        interrupted = true;
    }
  } finally {
    if (failed)
      cancelAcquire(node);
  }
}

```

#### 2.2 tryAcquire(int acquires)

1. 可重入锁 (独享锁/互斥锁) : ReentrantLock
  - 公平锁实现　 : FairSync
  - 非公平锁实现 : NonfairSync

##### 2.2.1 可重入锁 -> 公平锁实现　
```java
/**
 * Fair version of tryAcquire.  Don't grant access unless
 * recursive call or no waiters or is first.
 */
protected final boolean tryAcquire(int acquires) {
    // 当前线程
    final Thread current = Thread.currentThread();
    // 获取当前状态AQS状态
    int c = getState();
    if (c == 0) {
        // 如果没有等待的线程,则加锁
        if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    // 如果当前获得锁的线程是自己,则重入
    } else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```
```java
/**
 * true  : 如果在当前线程之前有一个排队的线程
 * false : 如果当前线程位于队列的头部或队列为空
 */
public final boolean hasQueuedPredecessors() {
    // The correctness of this depends on head being initialized
    // before tail and on head.next being accurate if the current
    // thread is first in queue.
    Node t = tail; // Read fields in reverse initialization order
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

##### 2.2.2 可重入锁 -> 非公平锁实现
```java
// 加锁
final void lock() {
    // 非公平锁进入就尝试加锁
    if (compareAndSetState(0, 1))
        // 获取到锁则设置独占线程为当前线程
        setExclusiveOwnerThread(Thread.currentThread());
    // 没获取到锁,则进入尝试加锁阶段 (见:2.1 获取锁)
    else
        acquire(1);
}
```
上面如果没有获取到锁,进入到acquire后,又会进入子类实现的tryAcquire
```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

/**
 * 执行块tryLock。tryAcquire是在子类中实现的，但两者都需要对trylock方法进行不公平的尝试。
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    // 获取当前加锁状态
    int c = getState();
    if (c == 0) {
        // 如果未加锁,尝试CAS加锁
        if (compareAndSetState(0, acquires)) {
            // 如果加锁成功,则设置独占线程为当前线程,然后返回进入到selfInterrupt
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 如果当前获取锁的线程为自己,则可重入,重入次数加1
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

##### 2.3 acquireQueued
如果当前线程获取锁失败,会把当前线程放入队列中,然后进入此方法
```java
final boolean acquireQueued(final Node node, int arg) {
    // 是否失败,默认失败
    boolean failed = true;
    try {
        // 是否被打断
        boolean interrupted = false;
        for (;;) {
            // 获得该节点的前节点
            final Node p = node.predecessor();
            // 如果前一个节点为队列头部,并且当前线程再次获取锁成功
            if (p == head && tryAcquire(arg)) {
                // 则头部为自己
                setHead(node);
                p.next = null; // help GC , 原来的头结点的下一个节点为null,即释放前一个锁
                failed = false;    // 成功
                return interrupted;// return false
            }
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
    if (ws > 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```
