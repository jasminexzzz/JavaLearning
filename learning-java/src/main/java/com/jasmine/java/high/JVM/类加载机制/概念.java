package com.jasmine.java.high.JVM.类加载机制;

public class 概念 {
    /**
     一、类加载机制的过程
        -1). 编译:
             1). 词法分析和输入到符号表
             2). 注解处理
             3). 语义分析和生成字节码

         1). 类加载: 将类的class文件读入内存,并为之创建一个java.lang.Class对象

                 在JVM中,一个类用器全限定类名(就是类名全称，带包路径的用点隔开，例如: java.lang.String)和其类加载器作为其唯一
             标识,例如在com.jasmine包中有一个名为Test的类,被类加载器ClassLoader的实例cl负责加载,则Test类对应的Class对象在JVM
             表示为(ProxyFactory , com.jasmine , cl),这意味着两个类加载器加载的同名类:(ProxyFactory , com.jasmine , cl)和
             (ProxyFactory , com.jasmine , cl1)是不同的,他们所加载的类也是不同,互不兼容的.


             类加载器加载Class流程图如下:
                                 (1)
                检测此类是否载入过,即在缓存区是否有此Class?
                                  |
                     ┌─── yes ────┴──── no ───┐
                     |                        ↓
                     |                       (2)
                     |                    父类加载器
                     |                    是否存在？
                     |            ┌── no ─────┴───── yes ──────┐
                     |            ↓                            ↓
                     |           (4)                          (3)
                     |　　  使用根类加载器                使用父类加载器
                     |　　  来载入目标类,                 去加载目标类,
                     |　　     是否成功?                    是否成功?
                     ├─── yes ────┴──── no ──┐        ┌── no ──┴── yes ────┐
                     |                       |        ↓                    |
                     |                       |       (5)                   |
                     |                       |   当前类加载器尝             |
                     |                       |   试寻找class文        　　　|
                     |                       |   件(从与此Class-      　　　|
                     |                       |   Lorder相关的类　　　       |
                     |                       |   路径中寻找），             |
                     |                       |   是否找到？？？             |
                     |                       |         |                   |
                     |                       |<── no ──┴─ yes ───┐         |
                     |                       |                   ↓         |
                     |                       |                  (6)        |
                     |                       |             再从文件中载入   |
                     |                       |                 class       |
                     |                       |             是否成功？？？   |
                     |                       |                   |         |
                     |                       |<── no ────────────┴─────────┤
                     |                       ↓                             |
                     |                      (7)                            |
                     |             ClassNotFoundException                  |
                     |                   抛出异常！！！                     |
                     |                       |                             |
                     └───────────────────────┼─────────────────────────────┘
                                             ↓
                                            (8)
                                 返回对应的java.lang.Class对象


         2). 类连接: 连接阶段负责把类的二进制数据合并到JRE中.可分为如下三个阶段
             (1). 验证: 检验被加载的类是否有正确的内部结构,并和其他类协调一致.
             (2). 准备: 为类的类变量分配内存,并设置默认初始值.
             (3). 解析: 将类的二进制数据中的符号引用替换成直接引用.

         3). 初始化: 对类进行初始化,主要是对类变量进行初始化,以下几种情况会使类初始化:
             (1). 创建类的实例:new , 反射 , 反序列化.
             (2). 调用某个类的类方法(静态方法).
             (3). 访问某个类或接口的类变量,或为该类变量赋值.
             (4). 使用反射方式强制创建某个类或接口对应的java.lang.Class对象,例如Class.forName("Person").
             (5). 初始化某个类的子类,当初始化某个类的子类时,该子类的所有父类都会被初始化.
             (6). 直接使用java.exe命令来运行某个主类.当运行某个主类时,程序会先初始化该主类.
             特殊情况
             (1). 被final修饰的类变量,如果该类变量的值在编译时就可以确定下来,那么这个类变量相当于宏变量(该类变量在常量池中),Java
                  编译器会在编译时直接把这个类变量出现的地方替换成它的值,因此即使程序使用该静态类变量,也不会导致该类的初始化

                  简而言之,final修饰的类变量在定义时就赋值,则调用时不会初始化该类.


     二、类加载机制
         1). 全盘负责:当一个类加载器负责加载某个Class时,该Class所依赖的和引用的其他Class全都由该类加载器负责载入,除非显式指定另
                      外一个类加载器来加载.

         2). 父类委托:先让父类加载器加载该Class,若父类无法加载才尝试从自己的类路径中加载该类.

         3). 缓存机制:缓存机制会保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区搜寻该Class,只有
                      当缓存区中不存在该Class对象时,系统才会读取该类的对应二进制数据,并将其转换为Class对象,存入缓存区,这就是为
                      什么修改了Class后,必须重新启动JVM,程序所做的修改才会生效的原因.

         类加载机制
         总结:双亲委派机制:如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每
                          一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其
                          搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载.

         为什么需要自定义类加载器:

          1).加密:java代码可以轻易的被反编译,如果你需要对你的代码进行加密以防止反编译,可以先将编译后的代码用加密算法加密,类加密
                  后就不能再使用java自带的类加载器了,这时候就需要自定义类加载器.

          2).从非标准的来源加载代码:字节码是放在数据库,甚至是云端,就可以自定义类加载器,从指定来源加载类.


     三、类加载器之间的关系

         根类加载器(引导类加载器) Bootstrap Classloader : 该加载器并不是Java实现的
              ↑
         扩展类加载器 Extension ClassLoader
              ↑
         系统类加载器(应用程序加载器) System ClassLoader (application ClassLoader)
              ↑
         用户类加载器

     四、自定义类加载器
        1). JVM中除了根类加载器之外的所有类加载器都是Classloader子类的实例.

     五. 类加载器(ClassLoader)
        ClassLoader主要对类的请求提供服务，当JVM需要某类时，它根据名称向ClassLoader要求这个类，然后由ClassLoader返回这个类的class对象。


     */

    public static void main(String[] args) {
        System.out.println(1);
    }
}
