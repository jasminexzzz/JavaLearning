## 设计模式

### 一、设计模式六大职责
1. 单一值则原则 (Single Responsibility Principle, SRP) :
    - 1). 一个类只承担一个职责,即我们要修改一个类时,要因为一个且只会因为一个原因而去修改它,例如我需要修改用户类,必定是因为用户属性发生了变化去修改,而不是因为部门发生变化,或者角色发生变化而去修改用户类.
    ```
    功能要单一
    ```


2. 开闭原则 (Open-Closed Principle, OCP) :
    - 1). 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
    - 2). 软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
    - 3). 抽象化是开闭原则的关键
    ```
    要加功能,别修改源码,创建接口加功能就加实现类
    要拓展,就用策略模式,代理模式,装饰者模式都可以
    ```


3. 里氏替换原则 (Liskov Substitution Principle, LSP) :
    - 1). 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
    - 2). 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
    - 3). 里氏代换原则是实现开闭原则的重要方式之一.


4. 依赖倒置原则 (Dependency Inversion  Principle, DIP) :
    - 1). 抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。
    - 2). 开闭原则是目标，里氏代换原则是基础，依赖倒置原则是手段.
    ```
    开发的时候,脑子里要想着功能的意义,而不是功能实现.
    比如 :
    我要上传图片,就调用一个 file.upload() 方法来上传,别想着实现类是上传到云服务、还是FTP、还是本地、还是什么鬼地方
    对于调用者来说,不关心具体的实现,只关心问题
    (就像你老板常说的,不问过程,只问结果)
    ```


5. 接口隔离原则 (Interface  Segregation Principle, ISP) :
    - 1). 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
    - 2). 每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。
    - 3). 接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。
    - 4). 在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥,不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便
    ```
    接口功能要细化,要内聚,不同的功能就放到不同的接口中

    ```


6. 迪米特法则 (Law of Demeter, LoD) :
    - 1). 一个软件实体应当尽可能少地与其他实体发生相互作用。
    - 2). 迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。
    - 3). 应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。
    ```
    方法之间的调用最好通过统一的转发来实现,对象之间不直接调用
    ```

### 二、设计模式
#### 1. 创建型模式
##### 单例模式:
单例模式的最大作用是减少对象创建,降低内存使用,提高使用对象时的速度.

###### 1). 饿汉 (线程安全)
```java
private static Singleton single = new Singleton();
```
###### 2). 懒汉 (非线程安全)
```java
private static Singleton single = null;
public static Singleton getInstance() {
    if(single == null){
        single = new Singleton();
    }
    return single;
}
```
###### 3). 双检索
```java
// 需要注意对象要加 [volatile] 关键字实现可见性
private static volatile Singleton single = null;
public static Singleton getInstance线程安全调优双重检查() {
    // 判断对象是否存在
    if(single == null){
        // 加锁
        synchronized (Singleton.class){
            // 第二次判断
            if(single == null) {
                single = new Singleton();
            }
        }
    }
    return single;
}
```


##### 建造者模式
##### 工厂模式:
##### 抽象工厂模式
##### 原型模式
通过克隆的方法创建动态创建运行中的对象

需要注意被克隆对象是否包含其他对象,即深拷贝浅拷贝的问题.

#### 2. 结构型模式:
##### 适配器模式
##### 装饰器模式:
##### 桥接模式
##### 组合模式
##### 外观模式
##### 享元模式
##### 代理模式:

#### 3. 行为型模式：
##### 模版方法模式
##### 命令模式
##### 迭代器模式
##### 观察者模式
##### 中介者模式
##### 备忘录模式
##### 解释器模式
##### 状态模式
##### 策略模式
##### 职责链模式
##### 访问者模式

### 三、容易混淆的模式
#### 1. 代理 / 策略 / 装饰者
|模式|使用|对象类型|可见|
|---|---|---|---|
|代理|需要一个代理类|通常代理多个对象|不知其调用的实际对象|
|策略|需要一个策略转化转化类|一个接口的不同实现的使用策略|只其对象但不知其实现|
|装饰|需要一个装饰器类<br/>装饰类继承装饰器类|一个对象的水平拓展|知道对象和实现,并且要组装起来|

1) 代理模式


2) 策略模式

3) 装饰模式
