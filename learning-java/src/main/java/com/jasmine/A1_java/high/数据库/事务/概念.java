package com.jasmine.A1_java.high.数据库.事务;

/**
 * @author : jasmineXz
 */
public class 概念 {
    /**
     一. 事务的四大特性 (ACID)
        1. <原子性> (Atomicity)
                原子性是指事务包含的所有操作要么全部成功,要么全部失败回滚.

        2. <一致性> (Consistency)
                一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态,也就是说一个事务执行之前和执行之后都必须处于一致性状态.

            例如:
                假设用户A和用户B两者的钱加起来一共是5000,那么不管A和B之间如何转账,转几次账,事务结束后两个用户的钱相加起来应该还得是5000,
            这就是事务的一致性.

        3. <隔离性> (Isolation)
                隔离性是当多个用户并发访问数据库时,比如操作同一张表时,数据库为每一个用户开启的事务,不能被其他事务的操作所干扰,多个并发事务
            之间要相互隔离.
                即要达到这么一种效果:对于任意两个并发的事务A和B,在事务A看来,B要么在A开始之前就已经结束,要么在A结束之后才开始,这样每个
            事务都感觉不到有其他事务在并发地执行.

        4. <持久性> (Durability)
                持久性是指一个事务一旦被提交了,那么对数据库中的数据的改变就是永久性的,即便是在数据库系统遇到故障的情况下也不会丢失提交事务的
            操作.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
     二. 事务隔离级别

         数据库和程序一样,也有并发的问题,在同时存在两个或者两个以上的数据库事务环境中,同一条记录甚至是不同记录都会由于SQL在不同时刻的执行产生
     不同的结果,甚至产生错误.于是便有了隔离级别这样的数据库的概念.

         ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
                                    (Dirty Read)    (Write Cover)   (NonRepeatable Read)   (Phantom Read)
         隔离级别	                    脏读	          写覆盖	         不可重复读	                幻读
         ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
         读未提交(Read uncommitted)	    可能	          可能	         可能                       可能
         ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
         读已提交(Read committed)	    不可能	      可能	         可能	                    可能
         ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
         可重复读(Repeatable read)	    不可能		  不可能	         可能
         ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
         可串行化(Serializable)	        不可能		  不可能	         不可能
         ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

         如果数据库不考虑事务的隔离性,则会发生以下几种情况:
             1. <脏读>.
                事务A : 访问数据库 -> 修改数据 -> 未提交;
                事务B : 访问数据库 -> 提取数据;
                提取的数据为修改后的数据,但这个数据其实并未提交.

             2. <不可重复读>.
                事务A : 访问数据库 -> A读取数据 -> 事务B -> A读取数据.
                事务B : 访问数据库 -> B修改数据 -> 提交.
                事务A第二次读取的数据为错误数据.

             3. <幻读>.
                事务A : 访问数据库 -> 修改全部数据 -> 未提交.
                事务B : 访问数据库 -> 插入数据 -> 提交.
                事务A : 提交数据 -> 获取数据 -> 有一条未修改.

         ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

         数据库提供了4中隔离级别:
             1. <读未提交> (Read uncommitted) :
                最低级别,任何情况都无法保证.
                读事务 : 会阻塞读事务, 会阻塞写事务
                写事务 : 不阻塞读事务, 会阻塞写事务.

                说个人话:
                A读取数据时 , B可以读, B可以写
                A写入数据时 , B可以读, B不能写.

         　　2. <读已提交> (Read committed) :
                可避免脏读的发生.
                读事务 : 不阻塞读事务, 不阻塞写事务.
                写事务 : 会阻塞读事务, 会阻塞写事务.

                说个人话:
                A读取数据时 , B可以读, B可以写.
                A写入数据时 , B不可以读, B不可以写.

                所以脏读可以避免,因为
                B修改数据,但未提交,这时A来读取数据,由于B未提交,所以A事务只能读取修改前的数据.

             3. <可重复读> (Repeatable read)
                可避免脏读、不可重复读的发生.
                读事务 : 不阻塞读事务, 会阻塞写事务.
                写事务 : 会阻塞读事务, 会阻塞写事务.

                说个人话:
                A读取数据时 , B可以读, B不可以写.
                A写入数据时 , B不可以读, B不可以写.

             4. <可串行化> (Serializable)
                可避免脏读、不可重复读、幻读的发生.
                读事务 : 会阻塞读事务, 会阻塞写事务.
                写事务 : 会阻塞读事务, 会阻塞写事务.

                说个人话:
                A读取数据时 , B不可以读, B不可以写.
                A写入数据时 , B不可以读, B不可以写.

                以上四种隔离级别最高的是可串行化级别,最低的是读未提交级别,当然级别越高,执行效率就越低.像可串行化这样的级别,就是以锁表的
            方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待,所以平时选用何种隔离级别应该根据实际情况.在MySQL数据库中默认的隔离级
            别为可重复读.
                在MySQL 数据库中 : 支持上面四种隔离级别,默认的为可重复读.
                在Oracle数据库中 : 只支持串行化级别和读已提交这两种级别,其中默认的为读已提交级别.

            注意 : 在实践中,我们一般采用读取已提交或者更低的事务隔离级别,配合各种并发访问控制策略来达到并发事务控制的目的.


        小知识:
        一. 简单的select语法,大大的事务道理
            select语法非常简单,相信接触sql的人没有不知道的吧.但是,将select放在事务中,它的处理规则恐怕很多人都不能完全说清楚吧.本文就给大
        家说一下在事务处理中使用select应该注意的地方.

            1. 如果数据库的隔离级别是读已提交(Read Committed),这是很多数据库默认的隔离级别.在这种情况下:
                1). 对于当前事务的更改,即便是未提交的,select也是可见的.
                2). 除了当前事务之外,select只能看到已提交的事务所做出的更改.往往会出现这种情况:同一个事务的两个相同的select语句,但是执行顺
                    序不同,也可能会返回不同的结果.两个select语句执行间隔的时间里,可能有其他的事务提交,数据被修改了.

            2. 如果数据库的隔离级别是可重复读,事务只能看到事务开始前已提交的数据.所以,select既不能看到未提交的数据,也不能看到事务在执行时被
        其它事务更新的已提交的数据.

            读已提交:
                同一个事务: 即便数据修改未提交,查询也是可见的.
                同一个事务: 两条相同的查询,结果可能不同,因为会受到其他事务的影响.
                不同的事务: 查询只能看到已提交事务的更改.

        二. 简单的update语法,大大的事务道理
            1. 如果数据库的隔离级别是读已提交(Read Committed),这是很多数据库默认的隔离级别.在这种情况下:如果事务要更新一条记录,而这条记录恰
        好被另一个运行中但未提交事务更改(被锁定或删除),则当前事务会阻塞,等待直到另一个事务提交或回滚后,再继续处理(First Updater Win Rule).
        如果另一个事务回滚了,那么当前事务可以继续执行,更新这条记录.如果另一个事务提交了,要分两种情形.第一种,要是这条记录被删除了,那么忽略这
        条记录；第二种,这条记录被更新了,需要重新判断这条记录是否满足谓词条件(where语句),满足则更新,不满足则忽略这条记录.

            2. 如果数据库的隔离级别是可重复读,事务只能看到事务开始前已提交的数据.所以,对于并发的更新操作,与读已提交是类似的.如果事务更新同
        一条记录,当前事务会阻塞直到另一个并发写的事务结束.如果另一个事务回滚,那么当前事务继续执行,更新这条记录.如果另一个事务提交了,当前事
        务会回滚,这里的处理与读已提交不同.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
======================================================================================================================================























































     */
}
