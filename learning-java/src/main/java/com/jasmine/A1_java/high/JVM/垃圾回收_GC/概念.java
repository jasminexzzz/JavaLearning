package com.jasmine.A1_java.high.JVM.垃圾回收_GC;

/**
 * @author : jasmineXz
 */
@SuppressWarnings("all")
public class 概念 {
    /**

     GC (Garbage Colllection) 是指Java虚拟机的垃圾回收过程,这个过程是Java虚拟机释放内存,防止内存溢出情况的发生.

     一. 运行时,怎么给类、对象分配内存?
        1. 根据运行时数据区域的划分可以知道,几乎所有的对象都在堆上分配,而类信息、常量、静态变量在方法区分配.
        2. 堆内存是分代管理的,对象优先在Eden分配；
        3. 大对象(所谓的大对象是指需要连续内存空间的java对象,如很长的字符串或者数组)直接进入老年代；
        4. 长期存活的对象将进入老年代,在垃圾回收时在Survivor中每熬过一次youngGC,他的年龄就增加1,直到到达指定的年龄就会被放入老年代.


     二. 哪些内存需要回收? 对象已经死亡吗?
        1. 堆内存 :
            判断堆内的对象是否可以回收,要判断这个对象实例是否确实没用,判断算法有两种：
            1). 引用计数法 :
                通过一个标志去记录每一个对象被引用的次数,当被引用时,就将该标志加1,当引用废弃时,就将该标志减1.当我们进行GC时,判断每个对象的
            对应标志,如果大于0,则说明有引用存在,不清除,否则就清除.

                这就是引用计数法.这种算法看起来非常的简单易懂,但是如果深入思考一下,就会发现它对于循环引用是无法判断的,两个对象仅仅相互引用,
            除此之外和程序再没有其他关联,这种情况下,这两个对象就会是无用的并且不会被清除.客观的说,引用计数法在现实中还是有应用案例的,例如微
            软公司的COM(Comontnt Object Model)技术、使用ActionScript 3 的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使
            用了引用计数算法进行内存管理.

                但是,主流的Java虚拟机里面没有选用引用计数算法来管理内存的,因此,了解这种思维即可.

            2). 可达性分析算法 (根搜索算法) :
                在主流的商用程序语言的主流实现中通常是通过可达性分析算法(Reachability Analysis)来判定对象是否存活的.
                这个算法的思路是通过一系列名为 "GC Roots" 的对象作为起点,从这个节点向下搜索,搜索所经过的路径称为引用链(Reference Chain),
            当一个对象到 "GC Roots" 没有任何引用链相连(图论的不可达)时,则证明该对象不可用.
                java中可以做为GC Roots的对象有如下几种：
                    ● 虚拟机栈(栈帧中的本地变量表)中的引用的对象；
                    ● 方法区中的类静态属性引用的对象；
                    ● 方法区中常量引用的对象；
                    ● 本地方法栈JNI(Native)的引用对象；

        2. 方法区:
            方法区回收主要有两部分：
            1). 废弃的常量:
                废弃的常量判断方法和堆中的对象类似,只要判断没有地方引用就可以回收.
            2). 无用的类:
                需要同时满足下面3个条件才能算是"无用的类"：
                (1). 该类的所有实例都已经被回收,也就是java堆中不存在该类的任何实例；
                (2). 加载该类的ClassLoader已经被回收；
                (3). 该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.
                虚拟机可以对于满足上面三个条件的无用类进行回收,仅仅是可以回收,具体能否回收,JVM提供了-Xnoclassgc参数进行控制.

     三. 如何回收
        GC有多种算法,不同的算法实现了不同的垃圾回收器,每种回收器对应了不同的场景:
        1. 回收算法 :
            1). 标记-清除(Mark-Sweep)算法：
                如它的名字一样,算法分 "标记" 和 "清除" 两个阶段 : 首先标记出所有需要回收的对象,在标记完成后统一回收掉被标记的对象.
                主要有两个缺点 :
                    (1). 效率问题 : 标记和清除效率都不高.
                    (2). 空间问题 : 标记清除后会产生大量空间碎片.

            2). 复制(Copying)算法 <新生代> :
                它将内存按容量分成大小相等的两块，每次只用一块，当这一块内存用完后，就将可用的对象复制到另外一块上面，然后一次性清除已用过那块
                的内存空间。优点是实现简单，运行效率高，缺点是内存缩小为原来的一半。

            3). 标记整理（Mark-Compact）算法 <老年代堆> :
                此算法仍然与标记-清除算法一样，第一步标记，第二步不是对无用对象清理，而是，让所有可用对象都向一端移动，然后直接清理掉端边界以外
                的内存。标记整理算法的优点是不会产生空间碎片。

            4). 分代收集（Generation Collection）算法：
                分代收集算法根据对象存活周期的不同将内存划为几块，一般把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集
                算法。在新生代中，每次垃圾回收时都发现大批对象死去，只有少量存活，那就选用复制算法，付出少量复制成本就可以完成收集。而老年代中
                对象存活率较高且没有空间进行担保（后面讲新生代的担保分配），就必须使用 "标记-清除" 或者 "标记-整理" 算法。

        2. 垃圾回收器 :
            垃圾回收器是垃圾回收算法的具体实现，一般不同的厂商或者不同版本的虚拟机都包含不同的垃圾收集器，并且一般会提供参数供用户选择在不用业
            务场景下组合出各个年代所使用的收集器。
            Hotspot虚拟机包含垃圾收集器如下:
            1). Serial(串行GC)收集器 : Serial收集器是一个新生代收集器，单线程执行，使用复制算法。它在进行垃圾收集时，必须暂停其他所有的工作线
                程(用户线程)。是Jvm client模式下默认的新生代收集器。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾
                收集自然可以获得最高的单线程收集效率。

            2). ParNew(并行GC)收集器 :
                ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。

            3). Parallel Scavenge(并行回收GC)收集器 :

            4). Serial Old(串行GC)收集器 :
                Serial Old是Serial收集器的老年代版本，它同样使用一个单线程执行收集，使用“标记-整理”算法。主要使用在Client模式下的虚拟机。

            5). Parallel Old(并行GC)收集器 :
                Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。

            6). MS(并发GC)收集器 :
                CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过
                程大致分为4个步骤：
                (1). 初始标记(CMS initial mark)
                (2). 并发标记(CMS concurrenr mark)
                (3). 重新标记(CMS remark)
                (4). 并发清除(CMS concurrent sweep)





























     */
}
