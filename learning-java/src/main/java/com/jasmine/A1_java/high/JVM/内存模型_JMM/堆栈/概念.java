package com.jasmine.A1_java.high.JVM.内存模型_JMM.堆栈;

public class 概念 {
    /*
                   栈heap     堆stack
                      |          |
                 类  引用   创建了一个对象
                  |   |          |
                  A   a   =   new A();
                          |
                   代表将右边对象的
                   地址传给了左边的
                   引用


     一、栈(heap)：
         1. 存放内容：
           1). 基本类型的变量数据。
               如局部变量(方法中的变量) int a = 1; a和1都在栈中.
           2). 局部引用变量。

         2. 销毁
            栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。

         3. 特点
           1). 栈中的内容可以共享.
           2). (优势)栈的速度比堆块,仅次于直接位于CPU中的寄存器.
           3). (劣势)栈中的数据大小与生命周期必须是确定的.




     二、堆(stack)：
         1. 存放内容：
           1). 数组.
           2). new出来的对象.
           3). 静态变量(实例变量)
           4). 成员变量(方法外部,类的内部)

         2. 销毁：
            堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(在方法的参数传递时很常
         见)，则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，垃圾回收器才会在合适的时候回收它。

         3. 特点
           1). 动态的分配内存大小.
           2). (劣势)运行时动态分配内存,存取速度慢.
           3). (优势)生存期不必事先高速编译器,又垃圾回收器自动回收.


     三、常量池(constant pool):
         1. 存放内容
           1). 被final修饰的基本类型和对象型(String为对象型).
           2). 类和接口的全限定名.
           3). 字段的名称和描述符.
           4). 方法的名称和描述符.

         3. 特点
           1). String特殊,如果是编译期就已经创建好的(双引号定义的)存储在常量池中,且equals相等的字符串在常量池只有一份.
           2). 如果是运行期(new出来的)存储在堆中.并且每new一次是一份.

    */
    public void stackTest(){
        /*
        编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字
        面值的地址，然后将a指向3的地址。接着处理int b = 3；
         */
        int a = 3;
        //在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。
        int b = 3;
        System.out.println(a);
        System.out.println(b);
    }



    public static void main(String[] args) {


        String a = new String("123");
        String b = new String("123");
        System.out.println(a.toString());
    }
}
